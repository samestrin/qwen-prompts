# ---------------------------------------------------------------------------
# Command: /code:analysis
#
# Description:
#   Calls the Gemini CLI to perform a high-level analysis of a codebase,
#   detailing its architecture, tech stack, and key components.
#
# Usage Examples:
#
#   1. Analyze the current directory:
#      /code:analysis
#
#   2. Analyze a specific directory:
#      /code:analysis analyzing the @./server/api/ directory
# ---------------------------------------------------------------------------

name = "code:analysis"
description = "Analyze entire codebase architecture and structure using Gemini's large context window"

prompt = """
# Comprehensive Directory Detection

## Method 1: Package File Analysis
The **PACKAGE_DIRS** is "`gemini -p "Analyze @package.json, @composer.json, @pyproject.toml, @Cargo.toml, @go.mod to identify primary source directories. Look for:
1. **pyproject.toml**: Check [tool.setuptools.packages.find] include patterns, [project.scripts] entry points
2. **package.json**: Check main, module, exports fields, or scripts pointing to source dirs
3. **composer.json**: Check autoload.psr-4 namespace mappings
4. **Cargo.toml**: Check [bin] or [lib] sections for source paths
5. **go.mod**: Infer from module name and common Go patterns
Return actual directory names (not generic like 'src'), one per line. Return empty if none found."`"

## Method 2: Common Source Directory Patterns
The **PATTERN_DIRS** is "`find . -maxdepth 2 -type d \\( -name src -o -name app -o -name lib -o -name components -o -name packages -o -name modules -o -name cmd -o -name internal -o -name pkg \\) 2>/dev/null | grep -v node_modules | grep -v .git | grep -v dist | grep -v build | sed 's|^\\.||' | head -5 | tr '\\n' ' '`"

## Method 3: Code Density Analysis  
The **DENSITY_DIRS** is "`find . -maxdepth 3 -type f \\( -name '*.py' -o -name '*.js' -o -name '*.ts' -o -name '*.tsx' -o -name '*.php' -o -name '*.go' -o -name '*.rs' -o -name '*.java' -o -name '*.cpp' -o -name '*.c' \\) 2>/dev/null | grep -v node_modules | grep -v .git | grep -v dist | grep -v build | grep -v __pycache__ | sed 's|/[^/]*$||' | sort | uniq -c | sort -nr | head -3 | awk '$1 >= 3 {print $2}' | sed 's|^\\.||' | tr '\\n' ' '`"

## Directory Combination Logic
The **COMBINED_DIRS** is "`echo \"$PACKAGE_DIRS $PATTERN_DIRS $DENSITY_DIRS\" | tr ' ' '\\n' | grep -v '^$' | sort | uniq | head -5 | tr '\\n' ' '`"

## Final Formatted Output
The **MAIN_DIRECTORIES** is "`if [ -n \"$COMBINED_DIRS\" ]; then echo \"$COMBINED_DIRS\" | tr ' ' '\\n' | grep -v '^$' | sed 's/^/@/' | tr '\\n' ' ' | sed 's/ $//' | tr ' ' ' '; else echo '@.'; fi`"

---

You are an expert software architect/engineer.

## Code Analysis/Review 
`gemini -p "{MAIN_DIRECTORIES} Provide a comprehensive technical analysis of this codebase. {{args}}

Your analysis should include:

1. **Project Overview** – Explain what the project does and its main goals.
2. **Architecture** – Describe the high-level architecture, core design patterns, and key modules.
3. **Technology Stack** – Languages, frameworks, tools, and libraries used.
4. **File/Module Map** – Identify and describe the most important files and directories.
   - Only the meaningful and functionally significant files.
   - Use real file paths. Group by directory using headers and lists.
   - Summarize related files when appropriate (e.g., tests, utils, etc.).
   - **Do not use a tree structure**
5. **Entry Points** – Which files start or bootstrap the application.
6. **Key Components** – Detail the most critical parts of the codebase and their responsibilities.
7. **Dependencies** – Major external dependencies and what they're used for.
8. **Configuration** – How the app is configured, with relevant files/envs/tools.
9. **Build & Deployment** – How the project is installed, executed, and deployed.
10. **Security Considerations** – Authentication patterns, data validation, potential vulnerabilities, security best practices.
11. **Performance Characteristics** – Database queries, caching strategies, bottlenecks, optimization opportunities.
12. **Testing Strategy** – Test coverage, frameworks used, test organization, missing test areas.
13. **Areas for Improvement** – Potential improvements, refactors, missing docs, or technical debt.`

---

Using ONLY the above technical output as context, provide a comprehensive technical overview in properly formatted **Markdown**.

For the file/module map:
- **Prioritize clarity and hierarchy**, not completeness.
- **Present real paths** with short descriptions.
- Do NOT guess or fabricate structure.
- Use bullet points, not tree diagrams.

Then **hard stop**.
"""

