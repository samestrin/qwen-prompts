# ---------------------------------------------------------------------------
# Command: /analyze:dependency
#
# Description:
#   Calls the Gemini CLI to analyze project dependencies.
#
# Usage Examples:
#
#   1. Run a general analysis:
#      /analyze:dependency
#
#   2. Focus on a specific package manager:
#      /analyze:dependency focusing on npm dependencies
# ---------------------------------------------------------------------------

name = "analyze:dependency"
description = "Analyze project dependencies, their usage, and potential issues"

prompt = """
## File Detection

The **DEPENDENCY_FILES** is "`files=(package.json requirements.txt composer.json Gemfile go.mod Cargo.toml pom.xml build.gradle package-lock.json yarn.lock Pipfile.lock Gemfile.lock go.sum Cargo.lock); existing_files=""; for file 
in "${files[@]}"; do if [ -f "$file" ]; then existing_files="$existing_files @$file"; fi; done; echo "$existing_files"`"

---

You are an expert software architect/engineer.

# Dependency Analysis
`gemini -p "{DEPENDENCY_FILES} @src/ @lib/ Analyze the dependencies in this project. {{args}}

1.  **Dependency Overview**: Total number of dependencies, main package manager(s) used.
2.  **Direct Dependencies**: List major dependencies with their versions and purpose.
3.  **Dependency Usage Analysis**: Which dependencies are actively used vs. unused?
4.  **Version & Security Analysis**: Are there outdated dependencies or known security vulnerabilities?
5.  **Bundle Size & Performance**: Identify large dependencies affecting bundle size.
6.  **Dependency Issues**: Look for conflicting versions, missing dependencies, or circular dependencies.
7.  **Recommendations**: Suggest dependencies to update or remove, security patches, and optimizations.

Include specific examples of dependency usage in the codebase with file references."`

---

Carefully review the Dependency Analysis, correct any formatting issues, and display in properly formatted **Markdown**. 

Then **hard stop**.
"""
