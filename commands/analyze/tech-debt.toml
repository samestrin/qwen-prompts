# ---------------------------------------------------------------------------
# Command: /analyze:tech-debt
#
# Description:
#   Calls the Gemini CLI to identify and prioritize technical debt.
#
# Usage Examples:
#
#   1. Run a general analysis:
#      /analyze:tech-debt
#
#   2. Focus on a specific severity:
#      /analyze:tech-debt focusing on critical severity issues
# ---------------------------------------------------------------------------

name = "analyze:tech-debt"
description = "Identify and prioritize technical debt across the codebase"

prompt = """
# Comprehensive Directory Detection

## Method 1: Package File Analysis
The **PACKAGE_DIRS** is "`gemini -p "Analyze @package.json, @composer.json, @pyproject.toml, @Cargo.toml, @go.mod to identify primary source directories. Look for:
1. **pyproject.toml**: Check [tool.setuptools.packages.find] include patterns, [project.scripts] entry points
2. **package.json**: Check main, module, exports fields, or scripts pointing to source dirs
3. **composer.json**: Check autoload.psr-4 namespace mappings
4. **Cargo.toml**: Check [bin] or [lib] sections for source paths
5. **go.mod**: Infer from module name and common Go patterns
Return actual directory names (not generic like 'src'), one per line. Return empty if none found."`"

## Method 2: Common Source Directory Patterns
The **PATTERN_DIRS** is "`find . -maxdepth 2 -type d \\( -name src -o -name app -o -name lib -o -name components -o -name packages -o -name modules -o -name cmd -o -name internal -o -name pkg \\) 2>/dev/null | grep -v node_modules | grep -v .git | grep -v dist | grep -v build | sed 's|^\\.||' | head -5 | tr '\\n' ' '`"

## Method 3: Code Density Analysis  
The **DENSITY_DIRS** is "`find . -maxdepth 3 -type f \\( -name '*.py' -o -name '*.js' -o -name '*.ts' -o -name '*.tsx' -o -name '*.php' -o -name '*.go' -o -name '*.rs' -o -name '*.java' -o -name '*.cpp' -o -name '*.c' \\) 2>/dev/null | grep -v node_modules | grep -v .git | grep -v dist | grep -v build | grep -v __pycache__ | sed 's|/[^/]*$||' | sort | uniq -c | sort -nr | head -3 | awk '$1 >= 3 {print $2}' | sed 's|^\\.||' | tr '\\n' ' '`"

## Directory Combination Logic
The **MAIN_DIRECTORIES** is "`echo "${PACKAGE_DIRS} ${PATTERN_DIRS} ${DENSITY_DIRS}" | tr ' ' '\\n' | grep -v '^$' | sort -u | head -10 | tr '\\n' ' ' | sed 's/ $//'`"

Your primary role is that of a software engineer.

### Technical Debt Analysis
`gemini -p "{MAIN_DIRECTORIES} Identify and analyze technical debt in this codebase. {{args}}

1.  **Code Debt**: Outdated patterns, TODOs, commented-out code, workarounds.
2.  **Architecture Debt**: Inconsistencies, tight coupling, circular dependencies.
3.  **Technology Debt**: Outdated dependencies, legacy code, security vulnerabilities.
4.  **Documentation Debt**: Missing or outdated docs, unclear APIs.
5.  **Test Debt**: Missing coverage, brittle tests, slow test suites.
6.  **Performance Debt**: Known bottlenecks, inefficient algorithms, missing caching.

**Debt Prioritization Matrix:**
For each debt item identified:
- ðŸ”´ Critical (fix immediately)
- ðŸŸ  High (fix within sprint)
- ðŸŸ¡ Medium (fix within quarter)
- ðŸŸ¢ Low (fix when convenient)

**Impact Assessment:**
- Development velocity impact
- Maintenance burden
- Security/reliability risks
- Performance implications

**Remediation Plan:**
- Quick wins (< 1 day effort)
- Short-term fixes (1-5 days)
- Long-term refactoring (weeks/months)
- Estimated effort for each major item"`

---

Carefully review the Technical Debt Analysis, correct any formatting issues, and display in properly formatted **Markdown**. 
"""
